#!/usr/bin/python

import math

import numpy
from twisted.internet import reactor, defer, threads

import rospy
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from sensor_msgs.msg import Image, CameraInfo
from std_msgs.msg import Header, Float64
from tf import transformations
import image_geometry

from ieee2014_controller.srv import SetEnabled
from ieee2014_maestro.srv import ClipPos, FireDart
import sys

import ieee2014_mission_runner
from ieee2014_mission_runner import coarse_targeting, fine_targeting

from ieee2014_vision.srv import *
from ieee2014_vision.msg import *

rospy.init_node('ieee2014_mission_runner')

xyzw_array = lambda o: numpy.array([o.x, o.y, o.z, o.w])
xy_array = lambda o: numpy.array([o.x, o.y])

class TopicReader(object):
    def __init__(self, topic_name, topic_type):
        self._sub = rospy.Subscriber(topic_name, topic_type,
            lambda msg: reactor.callFromThread(self._cb, msg))
        self._dfs = []
    
    def _cb(self, msg):
        for df in self._dfs:
            reactor.callLater(0, df.callback, msg)
        self._dfs = []
    
    def get_next_message(self):
        df = defer.Deferred()
        self._dfs.append(df)
        return df

pose_topic = TopicReader('pose', PoseStamped)
gun_camera_image_topic = TopicReader('gun_camera/image_rect_color', Image)
gun_camera_info_topic = TopicReader('gun_camera/camera_info', CameraInfo)
block_topic = TopicRead('block_positions', BlockPositions)

def wrap_blocking_func(f):
    def _(*args, **kwargs):
        return threads.deferToThread(f, *args, **kwargs)
    return _

controller_set_enabled = wrap_blocking_func(rospy.ServiceProxy(
    'controller/set_enabled', SetEnabled, persistent=True))
raw_change_clip_position = wrap_blocking_func(rospy.ServiceProxy(
    'change_clip_position', ClipPos, persistent=True))
fire_dart = wrap_blocking_func(rospy.ServiceProxy(
    'fire_dart', FireDart, persistent=True))
target_solver_set_enabled = wrap_blocking_func(rospy.ServiceProxy(
    'target_solver/set_enabled', SetEnabled, persistent=True))

@defer.inlineCallbacks
def change_clip_position(pos):
    yield raw_change_clip_position(pos)
    yield sleep(1)

controller_pub = rospy.Publisher('desired_pose', PoseStamped, queue_size=10)
pan_pub = rospy.Publisher('pan_controller/command', Float64)
tilt_pub = rospy.Publisher('tilt_controller/command', Float64)

def unpack_blocks(block_msg):
    block_positions = []
    for block in block_msg.blocks:
        block_positions.append((block.x,block.y))
        
    return block_positions


@defer.inlineCallbacks
def set_pan_tilt(pan, tilt):
    pan_pub.publish(Float64(
        data=pan % (2 * math.pi),
    ))
    tilt_pub.publish(Float64(
        data=tilt % (2 * math.pi),
    ))
    yield sleep(1) # it can take longer than this

@defer.inlineCallbacks
def go_to_point(point, angle=0):
    # sent point to controller
    def send_point():
        controller_pub.publish(PoseStamped(
            header=Header(
                frame_id='/course',
            ),
            pose=Pose(
                position=Point(point[0], point[1], 0),
                orientation=Quaternion(*transformations.quaternion_from_euler(0, 0, angle)),
            ),
        ))
    send_point()
    
    # enable controller
    yield controller_set_enabled(True)
    
    # wait until near point
    last_bad_time = rospy.Time.now()
    while True:
        send_point() # just to make sure...
        msg = yield pose_topic.get_next_message()
        distance = numpy.linalg.norm(xy_array(msg.pose.position) - point)
        angle_error = angle - transformations.euler_from_quaternion(xyzw_array(msg.pose.orientation))[2]
        while angle_error > +math.pi: angle_error -= 2*math.pi
        while angle_error < -math.pi: angle_error += 2*math.pi
        if distance > 0.05 or abs(angle_error) > 0.1:
            last_bad_time = rospy.Time.now()
        if rospy.Time.now() - last_bad_time > rospy.Duration(0.5):
            break
    
    # disable controller (stops wheels)
    yield controller_set_enabled(False)

@defer.inlineCallbacks
def turn_and_go(point):
    pose = yield pose_topic.get_next_message()
    angle = math.atan2(*(point - xy_array(pose.pose.position))[::-1])
    yield go_to_point(xy_array(pose.pose.position), angle)
    yield go_to_point(point, angle)
    yield go_to_point(point, 0)

def sleep(t):
    d = defer.Deferred(canceller=lambda d_: dc.cancel())
    dc = reactor.callLater(t, d.callback, None)
    return d

import cv2
from cv_bridge import CvBridge
bridge = CvBridge()
@defer.inlineCallbacks
def do_fine_targeting(current_angles):
    camera_info = yield gun_camera_info_topic.get_next_message()
    camera_model = image_geometry.PinholeCameraModel(); camera_model.fromCameraInfo(camera_info)
    
    img_msg = yield gun_camera_image_topic.get_next_message()
    img = numpy.array(bridge.imgmsg_to_cv(img_msg, "bgr8"))
    res = fine_targeting.get(img)
    
    x = camera_model.projectPixelTo3dRay(res)
    
    
    #yield sleep(5)
    print x
    
    delta_pan = -math.asin(x[0])
    delta_tilt = -math.asin(x[1]) - 0.03
    
    yield set_pan_tilt(
        pan=current_angles['pan'] + delta_pan,
        tilt=current_angles['tilt'] + delta_tilt,
    )
    #yield sleep(5)
    
    img_msg = yield gun_camera_image_topic.get_next_message()
    img = numpy.array(bridge.imgmsg_to_cv(img_msg, "bgr8"))
    cv2.imshow("post-fine targeting", img)
    #yield threads.deferToThread(cv2.waitKey)

@defer.inlineCallbacks
def main():
    # XXX wait for start
    
    
    # XXX look for blocks, fill in block_positions
    set_pan_tilt(0.3,0.0)

    
    rospy.wait_for_service('Detect_Blocks')
    block_detect_enable = rospy.ServiceProxy('Detect_Blocks', Detect_Blocks)

    block_msg = block_topic.get_next_message()
    blocks = unpack_blocks(block_msg)
    attempts = 0
    while(len(blocks) < 3):
        attempts +=1
        if attempts % 25 == 0:
            set_pan_tilt(0.4,0.0)
        print "Not enough blocks detected"
        block_msg = block_topic.get_next_message()
        blocks = unpack_blocks(block_msg)
        
    block_detect_enable(False)        
        
    start_pos = (-1.09, -0.34)
    
    block_positions = blocks
    
    #block_positions = [
    #    (-0.30, +0.19),
    #    (-0.00, -0.18),
    #    (+0.32, +0.20),
    #]
    end_pos = (1.03, -0.40)
    
    yield go_to_point(start_pos + numpy.array([0.2, 0]))
    
    for i, block_position in enumerate(block_positions):
        coarse_angles = coarse_targeting.think(block_position)
        coarse_target_task = set_pan_tilt(**coarse_angles)
        yield turn_and_go(block_position)
        
        sleep_task = sleep(3)
        
        yield coarse_target_task # should already be done
        yield sleep(2) # wait to stop moving
        yield do_fine_targeting(coarse_angles)
        
        yield sleep_task # wait remainder of 3 seconds
        
        yield change_clip_position(i+1)
        
        yield fire_dart(True) # internally waits 1 second
    yield go_to_point(end_pos)
    yield change_clip_position(4)

def run():
    def stopper(x):
        reactor.stop()
        return x
    return main().addBoth(stopper)
reactor.callWhenRunning(run)

reactor.callWhenRunning(lambda: rospy.core.add_client_shutdown_hook(
    lambda reason=None: reactor.callFromThread(reactor.stop)))
reactor.run()
