#!/usr/bin/python

import math

import numpy
from twisted.internet import reactor, defer, threads

import rospy
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from sensor_msgs.msg import Image, CameraInfo
from std_msgs.msg import Header, Float64
from tf import transformations
import image_geometry

from ieee2014_controller.srv import SetEnabled
from ieee2014_maestro.srv import ClipPos, FireDart
import sys

import ieee2014_mission_runner
from ieee2014_mission_runner import coarse_targeting, fine_targeting, util

from ieee2014_vision.srv import Detect_Blocks
from ieee2014_vision.msg import BlockPositions

rospy.init_node('ieee2014_mission_runner')

pose_topic = util.TopicReader('pose', PoseStamped)
gun_camera_image_topic = util.TopicReader('gun_camera/image_rect_color', Image)
gun_camera_info_topic = util.TopicReader('gun_camera/camera_info', CameraInfo)
block_topic = util.TopicReader('block_positions', BlockPositions)

controller_set_enabled = util.wrap_blocking_func(rospy.ServiceProxy(
    'controller/set_enabled', SetEnabled, persistent=True))
raw_change_clip_position = util.wrap_blocking_func(rospy.ServiceProxy(
    'change_clip_position', ClipPos, persistent=True))
fire_dart = util.wrap_blocking_func(rospy.ServiceProxy(
    'fire_dart', FireDart, persistent=True))
target_solver_set_enabled = util.wrap_blocking_func(rospy.ServiceProxy(
    'target_solver/set_enabled', SetEnabled, persistent=True))
detect_blocks = util.wrap_blocking_func(rospy.ServiceProxy(
    'Detect_Blocks', Detect_Blocks, persistent=True))

@defer.inlineCallbacks
def change_clip_position(pos):
    yield raw_change_clip_position(pos)
    yield util.sleep(1)

controller_pub = rospy.Publisher('desired_pose', PoseStamped, queue_size=10)
pan_pub = rospy.Publisher('pan_controller/command', Float64, queue_size=10)
tilt_pub = rospy.Publisher('tilt_controller/command', Float64, queue_size=10)

def unpack_blocks(block_msg):
    block_positions = []
    for block in block_msg.blocks:
        block_positions.append((block.x,block.y))
        
    return block_positions


@defer.inlineCallbacks
def set_pan_tilt(pan, tilt):
    pan_pub.publish(Float64(
        data=pan % (2 * math.pi),
    ))
    tilt_pub.publish(Float64(
        data=tilt % (2 * math.pi),
    ))
    yield util.sleep(1) # it can take longer than this

@defer.inlineCallbacks
def go_to_point(point, angle=0):
    # sent point to controller
    def send_point():
        controller_pub.publish(PoseStamped(
            header=Header(
                frame_id='/course',
            ),
            pose=Pose(
                position=Point(point[0], point[1], 0),
                orientation=Quaternion(*transformations.quaternion_from_euler(0, 0, angle)),
            ),
        ))
    send_point()
    
    # enable controller
    yield controller_set_enabled(True)
    
    # wait until near point
    last_bad_time = rospy.Time.now()
    while True:
        send_point() # just to make sure...
        msg = yield pose_topic.get_next_message()
        distance = numpy.linalg.norm(xy_array(msg.pose.position) - point)
        angle_error = angle - transformations.euler_from_quaternion(xyzw_array(msg.pose.orientation))[2]
        while angle_error > +math.pi: angle_error -= 2*math.pi
        while angle_error < -math.pi: angle_error += 2*math.pi
        if distance > 0.05 or abs(angle_error) > 0.1:
            last_bad_time = rospy.Time.now()
        if rospy.Time.now() - last_bad_time > rospy.Duration(0.5):
            break
    
    # disable controller (stops wheels)
    yield controller_set_enabled(False)

@defer.inlineCallbacks
def turn_and_go(point):
    pose = yield pose_topic.get_next_message()
    angle = math.atan2(*(point - xy_array(pose.pose.position))[::-1])
    yield go_to_point(xy_array(pose.pose.position), angle)
    yield go_to_point(point, angle)
    yield go_to_point(point, 0)

import cv2
from cv_bridge import CvBridge
bridge = CvBridge()
@defer.inlineCallbacks
def do_fine_targeting(approx_pos, current_angles):
    camera_info = yield gun_camera_info_topic.get_next_message()
    P = numpy.resize(camera_info.P, (3, 4))
    #camera_model = image_geometry.PinholeCameraModel(); camera_model.fromCameraInfo(camera_info)
    
    img_msg = yield gun_camera_image_topic.get_next_message()
    img = numpy.array(bridge.imgmsg_to_cv(img_msg, "bgr8"))
    res = fine_targeting.get(img, approx_pos, P)
    print res
    
    delta_pan = -math.asin(res[0]/P[0, 0])
    delta_tilt = -math.asin(res[1]/P[1, 1]) # - 0.03
    
    print delta_pan, delta_tilt
    
    yield set_pan_tilt(
        pan=current_angles['pan'] + delta_pan,
        tilt=current_angles['tilt'] + delta_tilt,
    )

@defer.inlineCallbacks
def main():
    # XXX wait for start
    
    
    # look for blocks, fill in block_positions
    yield set_pan_tilt(0.3, 0.0)
    
    for attempt in itertools.count():
        blocks = unpack_blocks((yield block_topic.get_next_message()))
        if len(blocks) >= 3:
            break
        print "Not enough blocks detected"
        if attempt % 25 == 0:
            set_pan_tilt(0.4, 0.0)
    
    detect_blocks(False)
    
    start_pos = (-1.09, -0.34)
    
    block_positions = blocks
    
    #block_positions = [
    #    (-0.30, +0.19),
    #    (-0.00, -0.18),
    #    (+0.32, +0.20),
    #]
    end_pos = (1.03, -0.40)
    
    yield go_to_point(start_pos + numpy.array([0.2, 0]))
    
    for i, block_position in enumerate(block_positions):
        coarse_angles = coarse_targeting.think(block_position)
        coarse_target_task = set_pan_tilt(**coarse_angles)
        yield turn_and_go(block_position)
        
        sleep_task = util.sleep(3)
        
        yield coarse_target_task # should already be done
        yield util.sleep(2) # wait to stop moving
        yield do_fine_targeting(coarse_angles)
        
        yield sleep_task # wait remainder of 3 seconds
        
        yield change_clip_position(i+1)
        
        yield fire_dart(True) # internally waits 1 second
    yield go_to_point(end_pos)
    yield change_clip_position(4)

@defer.inlineCallbacks
def main2():
    pos = (0, 0)
    
    yield util.sleep(1) # wait for things to connect...
    
    #yield set_pan_tilt(0.3, 0.0)
    #yield util.sleep(4)
    
    coarse_angles = coarse_targeting.think(pos)
    yield set_pan_tilt(**coarse_angles)
    
    yield util.sleep(2)
    
    yield do_fine_targeting(pos, coarse_angles)

def run():
    def stopper(x):
        reactor.stop()
        return x
    return main().addBoth(stopper)
reactor.callWhenRunning(run)

reactor.callWhenRunning(lambda: rospy.core.add_client_shutdown_hook(
    lambda reason=None: reactor.callFromThread(reactor.stop)))
reactor.run()
